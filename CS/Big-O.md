# big-O

> 코딩 인터뷰 189가지 프로그래밍 문제와 해범 완전 분석 - 프로그래밍 인사이트 책을 보고 비전공생으로 개발은 하고 있지만, 부족한 전공 지식에 대해 다시 한번 공부하고자 정리함

big-O 시간은 알고리즘의 효율성을 나타내는 지표 혹은 언어이다. 제대로 이해하지 못하면 알고리즘을 개발하는 데 큰 고비를 겪을 수 있다. big-O를 몰라 가혹한 비판을 당할지도 모를 뿐만 아니라, 알고리즘이 이전보다 얼마나 빨라졌는지 느려졌는지 판단하는 데도 어려움을 겪을 수 있다. 완벽히 이해가 필요하다.

<br>

### 시간 복잡도

예를 들어 물건을 다른 지역에 옮긴다고 가정하고 (책에서는 파일을 예시로 들었다) 만약에 비행기로 물건을 배송한다면 출발지에서 목적지까지 비행기로 걸리는 시간은 항상 동일할 것이다. 쉽게 말하면 우리가 여행 갈 때도 언제 어떤 비행기를 타던간에 거의 동일한 시간이 소요되어 비슷하게 도착하는 것을 생각하면 쉽다. 그리고 만약 비행기가 아니라 차로 운반한다면 얼마나 소요될까, 교통 혼잡도도 신경써야하고 물건에 대한 무게도 신경 써야할 것이다. 만약 교통 혼잡도가 없고 단지 물건에 대한 무게만 신경써야한다면 물건에 대한 무게 (N)에 비례하여 시간이 늘어날 것이다.

이것이 점근적 실행 시간(asymptotic runtime), 또는 big-O 시간에 대한 개념인데, 위 예시를 통해 간단히 설명하면 비행기를 통한 물건 배송은 O(1) 이라는 시간 복잡도를 가지고 차로 운반한다고 가정하면 물품 무게에 비례하기 때문에 O(n)이라는 시간 복잡도를 가진다. 여기서 O(1)은 상수를 의미하는데 여기서 상수란 비행기를 통해 걸리는 시간을 생각하면 된다. 비행기로 운반하는 경우에는 단순히 비행기가 도착지에 걸리는 시간만 생각하면 되기 때문이다. 하지만 차로 운반하는 경우 물건의 무게를 생각해야하기 때문에 O(n)이 시간 복잡도이며, n에 의해 복잡도가 늘어나거나 감소하기 때문이다.

이 외에도 다양한 실행 시간이 존재한다. 흔하게 사용되는 몇 가지를 예를 들면 다음과 같다. O(logN), O(NlogN), O(N), ...

<br>

### 최선의 경우, 최악의 경우, 평균적인 경우

실제로 알고리즘의 수행 시간을 세 가지 다른 방법으로 나타낼 수 있는데, 퀵 정렬(Quick Sort)의 관점에서 본다면 퀵 정렬은 '축'이 되는 원소 하나를 무작위로 뽑은 뒤 이보다 작은 원소들은 앞에, 큰 원소들은 뒤에 놓이도록 원소의 위치를 바꾼다. 그 결과 부분 정렬(Partial Sort)이 완성되고 그 뒤 왼쪽과 오른쪽 부분을 이와 비슷한 방식으로 재귀적으로 정렬해 나간다.

* 최선의 경우 : 만약 원소가 동일하다면 퀵 정렬은 평균적으로 단순히 배열을 한 차례 순회하고 끝날 것이다. O(N)이 실행 시간이 될 것이다. (물론 경우의 따라 <N이 될 수도 있다.)
* 최악의 경우 : 정말 최악의 경우에는 한 차례를 순회하는데, 왼쪽을 제외한 가장 큰 원소가 계속해서 기준 축이 된다면 동일한 배열을 여러 번 반복할 수 있다. 그렇다면 대략 O(N^2)이 실행 시간이 된다.
* 평균적인 경우: 평균적으로는 최악의 경우와 최선의 경우가 번갈아가면서 나타나겠지만, 계속해서 반복되진 않는다면 실행 시간은 약 O(NlogN)이 될 것이다.

항상 최선의 경우가 나타나려면 알고리즘 수행 전에 특수한 방법을 한 번 거친다면 가능할지도 모른다 하지만, 많은 알고리즘은 최악의 경우와 평균적인 경우가 같다. 가끔 이들이 달라서, 최악과 평균 두 경우가 따로 언급될 수도 있지만,..

<br>

### 공간 복잡도

알고리즘은 시간도 물론 중요하지만 메모리 혹은 공간이라고 하는 것도 신경 써야한다. 공간 복잡도는 시간 복잡도와 평행선을 달리는 개념인데, 크기가 n인 배열을 만든다고 하면, O(n)의 공간이 필요하고, n x n 크기의 2차원 배열을 만들고자 한다면 동일하게 O(n^2)의 공간이 필요한 것처럼 시간 복잡도와 유사하다. (시간 복잡도도 동일한 과정을 2번 반복한다면 O(2n)인 것과 비슷하다.)

아래 코드는 재귀 호출에 대표적인 예시인데, 이 코드는 시간 복잡도 O(n)과 공간 복잡도 O(n)을 사용한다.

```java
int sum(int n) {
    if (n <= 0) {
        return 0;
    }
    return n + sum(n-1);
}
```

```bash
sum(4)
    - sum (3)
        - sum (2)
            - sum (1)
                - sum (0) - exit
```

`sum(4)`를 실행하는 것을 예시로 든다면 총 `sum(0)`까지 가기 위해 `sum(4)`내부에서 총 4번의 함수를 호출하고 그 동안 메모리에는 각 재귀 호출에 대한 값을 4번 저장한다.


### 상수항은 무시하라

big-O는 단순히 증가하는 비율을 나타내는 개념으로, 여기서 증가하는 비율은 코드가 동작이 증가하는 비율을 의미하는 것이라고 생각된다. 그렇기에 특수한 입력으로 인해 O(N) 코드가 O(1) 보다 빠르게 동작하는 것은 매우 가능성 있는 이야기이기 때문에 수행 시간에서 상수항을 무시해 버린다. 즉 O(2N)으로 표기되어야 할 알고리즘을 실제로는 O(N)으로 표기한다.

그렇지만 많은 사람들이 이런 표기 방법을 달가워하지 않는데, 만약 두 개의 (중첩되지 않은) 루프로 이루어진 코드가 있을 때 어떤 사람은 여전히 O(2N)으로 표기한다. (음 이 부분에 대해서는 나도 그렇게 표기하는게 맞지 않나라고 생각했는데...?) 하지만 "정확한 표기법"이라 생각하면 그렇지 않다.

```python
# 하나의 반복문(루프)에 2개의 코드가 있는 경우
for x in array:
    if x < _min:
        _min = x
    if x > _max:
        _max = x

# 두 개의 반복문(루프)에 각각 1개의 코드가 있는 경우
for x in array:
    if x < _min:
        _min = x
for x in array:
    if x > _max:
        _max = x
```

위에 두 가지 코드가 있다고 보면 위에 작성한 코드는 반복문 하나만 돌았기에 O(N)으로 볼 수도 있고 아니, 하나의 반복문에서 두 개의 코드가 작동하기 때문에 O(2N)이라고 말할 수 있을 것이다. (맞나?) 하지만 내가 지금까지 big-O를 공부하면서 느낀 점은 단순히 반복하는 횟수에 대해 계산하기 때문에 위 코드 중 첫 번째 코드의 시간 복잡도는 O(N)이라고 볼 수 있다. 그러면 아래 코드는 어떠한가 생각해보면, 반복문이 2개가 있기 때문에 O(N) + O(N) = O(2N) 이라고 생각할 수 있다.

그럼 첫 번째 코드는 O(N) 두 번째 코드는 O(2N) 인데, 그럼 두 번째 코드가 첫 번째 코드보다 느린가를 생각해보면 사실 그렇지 않다. 결국 조건을 비교하는 행위는 동일하기 때문에 속도는 대체로 비슷할 것이다. (실제로 약 100,000개 라인의 숫자를 동일한 코드로 돌려보았는데 거의 비슷했다) 그렇다고 O(2N)이 O(N)과 비슷하다고 언제나 더 나은 것은 아니다. 단순히 표기법만 그렇다 할 뿐 기억하자.

<br>

### 배열에서의 삽입 시간

**ArrayList**(동적 가변크기 배열)는 배열의 역할을 함과 동시에 크기가 자유롭게 조절되는 자료구조이다. (파이썬의 리스트와 같은 역할로 보면 될 것 같다) 원소 삽입 시 필요에 따라 배열의 크기를 증가시킬 수 있기 때문에 ArrayList의 공간이 바닥날 일이 없다. ArrayList는 배열로 구현되어 있다. 배열의 용량이 꽉 찼을 때, ArrayList 클래스는 기존보다 크기가 두 배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 새 배열로 복사한다. (읽자마자 느낀건 음? 이래서 내가 리스트에 엄청 많은 데이터를 넣을 때 중간에 한두 번씩 시간이 오래 걸리고 그랬나...? 생각이 든다) 

그럼 이 때 삽입 연산의 수행 시간은 어떻게 되겠는가? 약간 까다로운 문제인데, 배열이 가득 차 있는 경우를 생각해보면 N개의 원소가 들어 있을 때 새로운 원소를 삽입하려면 O(N)이 걸린다. 왜냐하면 크기가 2N인 배열을 새로 만들고 기존의 모든 원소를 새 배열로 복사해야 하기 때문이다. 따라서 이 경우에 삽입 연산은 O(N) 시간이 소요된다. 하지만 가득 차 있는 경우는 극히 드물고, 대다수의 경우에는 배열에 가용 공간이 존재해 삽입 연산은 O(1)이 걸린다.


<br>


### 예제 및 연습 문제

**예제 1**

```java
void foo(int[] array) {
    int sum = 0;
    int product = 1;
    for (int i = 0; i < array.length; i++) {
        sum += array[i]
    }
    for (int i = 0; i < array.length; i++) {
        product *= array[i];
    }
    System.out.println(sum + ", " + product);
}
```

보면 루프는 입력받은 array의 데이터를 순차적으로 돌면서 코드를 실행시킨다. 자세히 살펴보면 첫 번째 루프에서는 단순히 합계를 계산하고 있고, 두 번째 루프에서는 각 원소를 계속 곱해가고 있다. 계산해보면 O(N) + O(N) = O(2N) 이고 표기법은 O(N)이다.

<br>

**예제 2**

```java
void printPairs(int[] array) {
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array.length; j++) {
            System.out.println(array[i] + "," + array[j]);
        }
    }
}
```

복잡한 과정 없이 두 개의 중첩 루프 안에 각각의 원소를 출력하는 코드로 O(N^2) 이 시간 복잡도가 된다.

<br>

**예제 3**

```java
void printUnorderedPairs(int[] array) {
    for (int i = 0; i < array.length; i++) {
        for (int j = i + 1; j < array.length; j++) {
            System.out.println(array[i] + "," + array[j])
        }
    }
}
```

위 예제와 거의 동일하다. 단순히 안쪽 루프가 `i+1` 에서부터 시작한다는 차이만 있다. O(N^2)dㅣ다.







