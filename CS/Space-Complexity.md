# 공간 복잡도

> ✔ **좋은 알고리즘**이란, 실행 시간이 짧고, 저장 공간도 적게 쓰는 알고리즘

- 알고리즘 계산 복잡도는 다음 두 가지 척도로 표현될 수 있음
    - 시간 복잡도 : 얼마나 빠르게 실행되는지
    - 공간 복잡도 : 얼마나 많은 저장 공간이 필요한지 (메모리, 저장 공간)
- 일반적으로 모두 만족시키기가 어렵다.
    - 시간과 공간은 반비례 관계를 갖고 있다.
    (공간이 많다면, 시간은 짧아진다. → 공간 속에서 찾는 시간이 감소)
    - 최근에는 대용량 시스템이 보편화되면서, **공간 복잡도**보다는 **시간 복잡도**가 **우선**

<br>

> ✔ **메모리** 뿐만 아니라, **저장 공간**에 대한 제약도 공간 복잡도에 포함된다.

- 최근 알고리즘 문제에서는 **시간 복잡도 제약**이 많으나**,** 기존 알고리즘 문제는 **공간 복잡도도 고려**되어야 할 떄 만들어진 경우가 많아, 제약 사항이 있을 수 있다.
    - 최근 현업에서는 빅데이터를 다룰 때 저장 공간을 고려하여 구현하는 경우가 많다.
- 제약 예시

```python
Complexity:
	- expected worst-case time complexity: O(N)   # 시간 복잡도
	- expected worst-case space complexity: O(N)  # 공간 복잡도
```

<br>

> ✔ 코드 실행 중 **동적**으로 할당되는 가변 공간에 대해 고려하는 것이 가장 중요

- 프로그램 실행 및 완료하는데 필요한 저장공간의 양을 뜻함
- 총 필요 저장 공간
    - 고정 공간 (알고리즘과 무관한 공간) : 코드 저장 공간, 단순 변수 및 상수
    - 가변 공간 (알고리즘 실행과 관련있는 공간) : 실행 중 동적으로 필요한 공간

<br>

### 예제 : n! 팩토리얼 구하기

- **fac 변수**에 n만큼 곱하면서 index라는 변수는 계속 변했기 떄문에 결국 **공간 복잡도는 O(1)**

```python
def factorial(n):
    fac = 1
    for index in range(2, n + 1):
        fac = fac * index
    return fac
```
<br>

- **재귀 용법**을 사용하면서 factorial 함수를 실행할 때마다 1~n만큼 변수 n을 파라미터로 갖는 factorial(n)이 만들어지게 되면서, **공간 복잡도는 O(n)**

```python
def factorial(n):
    if n > 1:
        return n * factorial(n - 1)
    else:
        return 1
```