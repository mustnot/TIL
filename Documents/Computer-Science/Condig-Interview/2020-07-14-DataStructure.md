# Data Structure

>자료 구조에 대해 한번 정리하고 넘어간다. 어느 정도 안다고 생각하더라도 다시 정리하면 내가 기억했던 내용과 다를 수 있기 때문에 리마인드하는 마음으로 정리

<br>

## Array vs ArrayList

**배열** (Array)은 메모리 공간에 할당할 사이즈를 미리 정해놓고 사용하는 자료구조이다. 여기서 중요한건 `Python`에서 자주 사용하는 `List`와 동일하다고 생각하면 안된다. (비전공자인 나도 그렇게 생각했다) 그 이유는 `List`는 `Array`와 달리 사이즈를 미리 정해놓고 사용하는 구조가 아니라, 데이터를 넣으면 넣은 만큼 사이즈가 커지고, 삭제하면 그 만큼 또 줄어드는 구조이기 때문에 `Array`와 다르다. 

> 💡 참고 : `Python`에도 `Array`가 있다. 일반적으로 머신 러닝이나 딥러닝에 자주 사용하는 `numpy` 라이브러리의 `array` 라던가,  내장 모듈로 제공하는 `array` 가 있다. 



**동적 배열** (ArrayList)는 단어 그대로 배열과 달리 동적으로 즉 크기가 고정되지 않은 배열을 의미하는데, `C++`에서는 `vector`가 있고 `Java`에는 `ArrayList`가 있다. 위에서 언급한 `Python`의 `List` 역시 **동적 배열**에 속한다. 이렇듯 크기를 정해놓지 않기 때문에 동적 배열을 사용하면 개발자로 하여금 편하게 개발할 수 있는 여건을 마련해주는데, 여기서 문제는 배열의 크기가 제한되어 있지 않기 때문에 배열 안에 얼마나 데이터가 들어있을 수 있고, 얼마나 많은 데이터들이 있는지 식별하기 어려운 문제점이 있다.

<br>

### Array와 ArrayList의 장단점

그럼 **배열**과 **동적 배열**의 장단점은 무엇이 있을까 살펴보면, 배열은 `index`로 값을 빠르게 찾는게 가능하다는 장점이 있고, 이런 장점은 동적 배열 역시도 갖고 있다. 하지만 차이점으로는 동적 배열의 경우 삽입과 삭제가 느리다는 단점이 있는데, 데이터가 적은 경우에는 상관이 없지만, 데이터가 많아질 경우 동적 배열의 경우 크기가 비대하게 커질 수 있기 때문에 데이터의 위치를 찾아 삭제하거나 변경하는 것이 오래걸리고, 추가하더라도 일정 크기가 넘어가게 되면 삽입이 느려지는 문제가 있다.



<br>

## LinkedList

> 나는 약간 링크드 리스트를 열차와 비슷하다고 생각했다. 열차의 연결은 생각해보면 끝도 없이 연결 가능한 구조가 아닐까 생각된다. 공간이 허락하는 한? 그러다보니 중간에 데이터를 연결하거나 이럴 때 어떠한 과정으로 이해하면 좋을지 생각하니 어느 정도 이해하는데 편했던 것 같다.

**링크드 리스트** (LinkedList)는 연결 리스트라고도 한다. 배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조라고 한다면, 링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결하여 관리하는 데이터 구조로 데이터를 담고 있는 노드들이 연결되어 있어, 노드의 포인터가 다음 혹은 이전의 노드와의 연결을 담당하여 자료의 추가와 삭제가 빠르게 이루어진다는 장점이 있다. 하지만 특정 위치의 데이터를 찾기 위해서는 순차적으로 연결된 노드를 따라서 탐색해야하기에 `O(n)`의 시간이 걸리는 단점이 있다.

<br>

### LinkedList의 구조와 용어

* 노드 (Node) : 데이터 저장 단위 (데이터 값, 포인터)로 구성
* 포인터 (Pointer) : 각 노드 안에서 다음 혹은 이전의 노드와의 연결 정보를 가지고 있는 공간

<br>

### LinkedList의 장단점

* 장점
    * 배열과 달리 데이터 공간을 미리 할당하지 않아도 됨
* 단점
    * 연결을 위한 별도 데이터 공간이 필요하기에, 저장 공간 효율이 좋지 않음 (공간 복잡도에 영향)
    * 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림 (링크드 리스트의 n번째 데이터를 찾아라)
    * 중간 데이터 삭제시, 앞 뒤 데이터 연결을 재구성해야 하는 부가적인 작업 필요



<br>

## Stack

**스택** (Stack)은 말 그대로 스택 쌓는다고 생각하면 좋을 것 같은데, 탑을 쌓는다고 생각하면 탑의 중간과 첫 부분을 제거하기 위해서 가장 위에서부터 순차적으로 제거해야하는데, 이런 구조를 가진 것이 바로 스택이다. 스택은 LIFO (후입선출) 구조를 띄는 데이터 형태로 가장 나중에 들어온 것이 가장 먼저 나오는 형태를 띄고 있다.

`Python`에서는 `List`를 사용해도 될 정도로 동일한 구조를 띄고 있다. (이쯤되면 `List` 밖에 모르는 것 같은 나..) 그 이유는 `Stack`에 기본적인 메소드 두 개를 모두 포함하고 있기 때문이다. 명칭은 다르지만, 동일한 기능을 수행하는 메소드가 모두 포함되어 있다. 근데 큰 차이점이 있는데 스택의 기본 가정은 데이터의 크기가 정해져있다는 점이다. `List`와 비슷하다면서 무슨 소리야라고 생각했었는데, 배열을 이용하여 구현하는 걸로 봐서 기본적으로 크기를 정하는 것을 알 수 있다.



### 연산자

* push() : 스택의 가장 위에 데이터를 넣는다.
* pop() : 스택의 가장 위 데이터를 삭제한다.
* empty() : 스택이 비었다면 1을 반환하고, 그렇지 않다면 0을 반환한다.
* top() : 가장 위에 데이터를 반환한다.







