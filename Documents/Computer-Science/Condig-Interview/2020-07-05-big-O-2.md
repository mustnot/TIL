# big-O - 2

> 앞선 글 이어서 계속 작성

<br>

### 상수항은 무시하라

big-O는 단순히 증가하는 비율을 나타내는 개념으로, 여기서 증가하는 비율은 코드가 동작이 증가하는 비율을 의미하는 것이라고 생각된다. 그렇기에 특수한 입력으로 인해 O(N) 코드가 O(1) 보다 빠르게 동작하는 것은 매우 가능성 있는 이야기이기 때문에 수행 시간에서 상수항을 무시해 버린다. 즉 O(2N)으로 표기되어야 할 알고리즘을 실제로는 O(N)으로 표기한다.

그렇지만 많은 사람들이 이런 표기 방법을 달가워하지 않는데, 만약 두 개의 (중첩되지 않은) 루프로 이루어진 코드가 있을 때 어떤 사람은 여전히 O(2N)으로 표기한다. (음 이 부분에 대해서는 나도 그렇게 표기하는게 맞지 않나라고 생각했는데...?) 하지만 "정확한 표기법"이라 생각하면 그렇지 않다.

```python
# 하나의 반복문(루프)에 2개의 코드가 있는 경우
for x in array:
  if x < _min:
    _min = x
  if x > _max:
    _max = x

# 두 개의 반복문(루프)에 각각 1개의 코드가 있는 경우
for x in array:
  if x < _min:
    _min = x
for x in array:
  if x > _max:
    _max = x
```

위에 두 가지 코드가 있다고 보면 위에 작성한 코드는 반복문 하나만 돌았기에 O(N)으로 볼 수도 있고 아니, 하나의 반복문에서 두 개의 코드가 작동하기 때문에 O(2N)이라고 말할 수 있을 것이다. (맞나?) 하지만 내가 지금까지 big-O를 공부하면서 느낀 점은 단순히 반복하는 횟수에 대해 계산하기 때문에 위 코드 중 첫 번째 코드의 시간 복잡도는 O(N)이라고 볼 수 있다. 그러면 아래 코드는 어떠한가 생각해보면, 반복문이 2개가 있기 때문에 O(N) + O(N) = O(2N) 이라고 생각할 수 있다.

그럼 첫 번째 코드는 O(N) 두 번째 코드는 O(2N) 인데, 그럼 두 번째 코드가 첫 번째 코드보다 느린가를 생각해보면 사실 그렇지 않다. 결국 조건을 비교하는 행위는 동일하기 때문에 속도는 대체로 비슷할 것이다. (실제로 약 100,000개 라인의 숫자를 동일한 코드로 돌려보았는데 거의 비슷했다) 그렇다고 O(2N)이 O(N)과 비슷하다고 언제나 더 나은 것은 아니다. 단순히 표기법만 그렇다 할 뿐 기억하자.

<br>

### 배열에서의 삽입 시간

**ArrayList**(동적 가변크기 배열)는 배열의 역할을 함과 동시에 크기가 자유롭게 조절되는 자료구조이다. (파이썬의 리스트와 같은 역할로 보면 될 것 같다) 원소 삽입 시 필요에 따라 배열의 크기를 증가시킬 수 있기 때문에 ArrayList의 공간이 바닥날 일이 없다. ArrayList는 배열로 구현되어 있다. 배열의 용량이 꽉 찼을 때, ArrayList 클래스는 기존보다 크기가 두 배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 새 배열로 복사한다. (읽자마자 느낀건 음? 이래서 내가 리스트에 엄청 많은 데이터를 넣을 때 중간에 한두 번씩 시간이 오래 걸리고 그랬나...? 생각이 든다) 

그럼 이 때 삽입 연산의 수행 시간은 어떻게 되겠는가? 약간 까다로운 문제인데, 배열이 가득 차 있는 경우를 생각해보면 N개의 원소가 들어 있을 때 새로운 원소를 삽입하려면 O(N)이 걸린다. 왜냐하면 크기가 2N인 배열을 새로 만들고 기존의 모든 원소를 새 배열로 복사해야 하기 때문이다. 따라서 이 경우에 삽입 연산은 O(N) 시간이 소요된다. 하지만 가득 차 있는 경우는 극히 드물고, 대다수의 경우에는 배열에 가용 공간이 존재해 삽입 연산은 O(1)이 걸린다.


<br>


### 예제 및 연습 문제

**예제 1**

```java
void foo(int[] array) {
  int sum = 0;
  int product = 1;
  for (int i = 0; i < array.length; i++) {
    sum += array[i]
  }
  for (int i = 0; i < array.length; i++) {
    product *= array[i];
  }
  System.out.println(sum + ", " + product);
}
```

보면 루프는 입력받은 array의 데이터를 순차적으로 돌면서 코드를 실행시킨다. 자세히 살펴보면 첫 번째 루프에서는 단순히 합계를 계산하고 있고, 두 번째 루프에서는 각 원소를 계속 곱해가고 있다. 계산해보면 O(N) + O(N) = O(2N) 이고 표기법은 O(N)이다.

<br>

**예제 2**

```java
void printPairs(int[] array) {
  for (int i = 0; i < array.length; i++) {
    for (int j = 0; j < array.length; j++) {
      System.out.println(array[i] + "," + array[j]);
    }
  }
}
```

복잡한 과정 없이 두 개의 중첩 루프 안에 각각의 원소를 출력하는 코드로 O(N^2) 이 시간 복잡도가 된다.

<br>

**예제 3**

```java
void printUnorderedPairs(int[] array) {
  for (int i = 0; i < array.length; i++) {
    for (int j = i + 1; j < array.length; j++) {
      System.out.println(array[i] + "," + array[j])
    }
  }
}
```

위 예제와 거의 동일하다. 단순히 안쪽 루프가 `i+1` 에서부터 시작한다는 차이만 있다. O(N^2)dㅣ다.



















