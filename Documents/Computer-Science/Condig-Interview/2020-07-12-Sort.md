# Sort

> 그간 공부했던 정렬 알고리즘에 대한 정리와 추가적인 알고리즘에 대한 정리

정렬 알고리즘은 정렬 방식에 따라 여러 방식의 알고리즘들이 존재한다. 알고리즘 종류만 따지더라도 `선택 정렬(Selection Sort)` 부터 `Bubble Sort`, `Quick Sort` 등 다양하게 있다. 



<br>



# Selection Sort (선택 정렬)

Selection Sort (선택 정렬)은 **제자리 정렬** 알고리즘 중 하나로 주어진 리스트 중 최소값을 찾고, 그 값을 맨 앞 앞에 위치한 값과 교체하는 방식으로 그 다음에는 앞 전에 교체한 위치를 뺀 나머지 리스트의 맨 앞에 위치와 교체한다.

<br>

## Process (Ascending)

1. 배열에서 최소값을 찾는다.
2. 찾은 최소값을 배열에서 가장 맨 앞에 위치한 값과 교체한다.
3. 교체한 맨 앞의 값을 제외한 배열에서 1번 과정부터 다시 반복

<br>

## Python Code

> 변수명 짓기 너무나 어려운 것..

**Code 1**

```python
def selection_sort(arr, ascending=True):
    for ix in range(len(arr)-1):
        _min = ix
        for jx in range(ix+1, len(arr)):
            if arr[jx] < arr[_min]:
                _min = jx
        arr[_min], arr[ix] = arr[ix], arr[_min]

    return arr
```



**Code 2**

```python
def selection_sort(data):
    for stand in range(len(data) - 1):
        lowest = stand
        for index in range(stand + 1, len(data)):
            if data[lowest] > data[index]:
                lowest = index
        data[lowest], data[stand] = data[stand], data[lowest]
    return data
```

<br>

## Big-O

시간 복잡도를 계산하면 첫 번째 반복문에서 `n` 만큼 돌 것이고, 두 번째 반복문에서는 첫 번째 루프를 지날 때마다 `n-1`, `n-2`, `...` 로 점차 감소할테지만, 그래도 `n`만큼 돌기 때문에 시간 복잡도는 `O(n^2)`다.

공간 복잡도는 배열 안에서만 모든 작업이 이루어지기 때문에 `O(n)` 이다.



<br>



# Bubble Sort (거품 정렬)

> 거품 정렬이 왜 거품 정렬일까라고 생각했는데, 원소의 이동이 마치 거품이 수면으로 올라오는 듯한 모습을 보인다고 해서 지어졌다고 한다. 궁금하면 [Bubble Sort - Wikipedia]([https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC](https://ko.wikipedia.org/wiki/거품_정렬))

거품 정렬은 Selection Sort와 유사하다고 볼 수 있는데, 그 이유는 리스트의 값을 하나 씩 순회하며 인접한 두 원소를 비교하고 자리를 교환하면서 정렬하는 알고리즘이다. 여기서 리스트를 순차적으로 순회한다는 점에서 어느 정도 유사한 면이 있다.

<br>

## Process (Ascending)

1. 첫 번째와 두 번째 원소를 비교, 그 후 두 번째와 세 번째 원소를 비교하는 방식으로 n 번째와 n+1 번째의 원소를 비교하여 이 중 조건에 의해 자리를 교환한다. 여기서 조건은 오름차순인지, 내림차순인지 이다.
2. (오름차순) 1번 과정을 거치면 가장 끝에 있는 원소의 값이 가장 크게 되어 다음 과정 진행할 때에는 마지막 위치를 제외하고 1번 과정을 반복한다.

<br>

## Python Code

**Code 1**

```python
def bubble_sort(arr, ascending=True):
    end = len(arr)
    while end > 0:
        for ix in range(end-1):
            if arr[ix] > arr[ix+1]:
                arr[ix], arr[ix+1] = arr[ix+1], arr[ix]
        end -= 1
    return arr
```

**Code 2**

```python
def bubble_sort(data):
    for index in range(len(data) - 1):
        swap = False
        for index2 in range(len(data) - index - 1):
            if data[index2] > data[index2 + 1]:
                data[index2], data[index2 + 1] = data[index2 + 1], data[index2]
                swap = True
        
        if swap == False:
            break
    return data
```

<br>

## Big-O

**시간 복잡도**는 반복문을 살펴보면 `(n-1) + (n-2) + ... + 2 + 1`로 점점 감소한다. 이는 `n(n-1)/2`으로 `O(n^2)`이다.

**공간 복잡도**는 배열 내부에서 위치를 바꾸는 방식이기 때문에 선택 정렬과 동일하게 `O(n)`이다.



<br>



# 삽입 정렬 (Insertion Sort)

삽입 정렬은 리스트의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘으로 선택 정렬과 유사하지만 더 효율적인 정렬 알고리즘으로 두 번째 인덱스부터 시작한다는 특이점이 있다. 

<br>

## Process

- 삽입 정렬은 버블 정렬과 달리 두 번째 인덱스부터 시작한다.
- 해당 인덱스(Key 값) 앞에 있는 데이터부터 비교하여 Key 값이 더 작으면 B 값을 뒤 인덱스로 복사 이를 Key값이 더 큰 데이터를 만날 때까지 반복, 그리고 큰 데이터를 만난 위치 바로 뒤에 Key 값을 이동


<br>


## Python Code

> 나는 처음 삽입 정렬이라길래 특정 리스트에 삽입해서 하는 줄 알았다. Code1은 처음에 짠 코드

**Code 1**

```python
def insertion_sort(arr, ascending=True):
    temp = [arr[0]]
    for idx in range(1, len(arr)):
        temp.append(arr[idx])
        for idx2 in range(idx, 0, -1):
            if temp[idx2] < temp[idx2-1]:
                temp[idx2], temp[idx2-1] = temp[idx2-1], temp[idx2]
            else:
                break
    return temp
```

**Code 2**

```python
def insertion_sort(data):
    for index in range(len(data) - 1):
        for index2 in range(index + 1, 0, -1):
            if data[index2] < data[index2 - 1]:
                data[index2], data[index2 - 1] = data[index2 - 1], data[index2]
            else:
              break
    return data
```

<br>

## Big-O

**시간 복잡도**는 최악의 경우 두 개의 반복문을 처음과 끝까지 돈다고 가정했을 때, 선택 정렬과 동일하게 `O(n^2)`이다. 효율적이라면서 선택 정렬과 동일하면 어쩌자는건가라고 생각할 수 있겠는데, 선택 정렬은 데이터가 어느 정도 정렬이 되어 있든 없든 항상 `O(n^2)`인데 반면에 삽입 정렬은 좌측에 정렬된 데이터가 어느 정도 순서를 유지하고 있기 때문에 중도에 멈추기도하여 `O(n^2)`보다는 항상 적은 시간 복잡도를 가진다.

**공간 복잡도**는 주어진 리스트에서 위치를 교환하기 때문에 `O(n)`이다. 하지만, **Code 1**의 경우에는 `temp`라는 리스트를 생성하여 그 안에서 정렬을 수행했기 때문에 `O(2n)`이다. (메모리를 2배나 차지한다.)









