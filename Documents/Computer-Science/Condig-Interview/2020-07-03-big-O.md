# big-O

> 코딩 인터뷰 189가지 프로그래밍 문제와 해범 완전 분석 - 프로그래밍 인사이트 책을 보고 비전공생으로 개발은 하고 있지만, 부족한 전공 지식에 대해 다시 한번 공부하고자 정리함

big-O 시간은 알고리즘의 효율성을 나타내는 지표 혹은 언어이다. 제대로 이해하지 못하면 알고리즘을 개발하는 데 큰 고비를 겪을 수 있다. big-O를 몰라 가혹한 비판을 당할지도 모를 뿐만 아니라, 알고리즘이 이전보다 얼마나 빨라졌는지 느려졌는지 판단하는 데도 어려움을 겪을 수 있다. 완벽히 이해가 필요하다.

<br>

### 시간 복잡도

예를 들어 물건을 다른 지역에 옮긴다고 가정하고 (책에서는 파일을 예시로 들었다) 만약에 비행기로 물건을 배송한다면 출발지에서 목적지까지 비행기로 걸리는 시간은 항상 동일할 것이다. 쉽게 말하면 우리가 여행 갈 때도 언제 어떤 비행기를 타던간에 거의 동일한 시간이 소요되어 비슷하게 도착하는 것을 생각하면 쉽다. 그리고 만약 비행기가 아니라 차로 운반한다면 얼마나 소요될까, 교통 혼잡도도 신경써야하고 물건에 대한 무게도 신경 써야할 것이다. 만약 교통 혼잡도가 없고 단지 물건에 대한 무게만 신경써야한다면 물건에 대한 무게 (N)에 비례하여 시간이 늘어날 것이다.

이것이 점근적 실행 시간(asymptotic runtime), 또는 big-O 시간에 대한 개념인데, 위 예시를 통해 간단히 설명하면 비행기를 통한 물건 배송은 O(1) 이라는 시간 복잡도를 가지고 차로 운반한다고 가정하면 물품 무게에 비례하기 때문에 O(n)이라는 시간 복잡도를 가진다. 여기서 O(1)은 상수를 의미하는데 여기서 상수란 비행기를 통해 걸리는 시간을 생각하면 된다. 비행기로 운반하는 경우에는 단순히 비행기가 도착지에 걸리는 시간만 생각하면 되기 때문이다. 하지만 차로 운반하는 경우 물건의 무게를 생각해야하기 때문에 O(n)이 시간 복잡도이며, n에 의해 복잡도가 늘어나거나 감소하기 때문이다.

이 외에도 다양한 실행 시간이 존재한다. 흔하게 사용되는 몇 가지를 예를 들면 다음과 같다. O(logN), O(NlogN), O(N), ...

<br>

### 최선의 경우, 최악의 경우, 평균적인 경우

실제로 알고리즘의 수행 시간을 세 가지 다른 방법으로 나타낼 수 있는데, 퀵 정렬(Quick Sort)의 관점에서 본다면 퀵 정렬은 '축'이 되는 원소 하나를 무작위로 뽑은 뒤 이보다 작은 원소들은 앞에, 큰 원소들은 뒤에 놓이도록 원소의 위치를 바꾼다. 그 결과 부분 정렬(Partial Sort)이 완성되고 그 뒤 왼쪽과 오른쪽 부분을 이와 비슷한 방식으로 재귀적으로 정렬해 나간다.

* 최선의 경우 : 만약 원소가 동일하다면 퀵 정렬은 평균적으로 단순히 배열을 한 차례 순회하고 끝날 것이다. O(N)이 실행 시간이 될 것이다. (물론 경우의 따라 <N이 될 수도 있다.)
* 최악의 경우 : 정말 최악의 경우에는 한 차례를 순회하는데, 왼쪽을 제외한 가장 큰 원소가 계속해서 기준 축이 된다면 동일한 배열을 여러 번 반복할 수 있다. 그렇다면 대략 O(N^2)이 실행 시간이 된다.
* 평균적인 경우: 평균적으로는 최악의 경우와 최선의 경우가 번갈아가면서 나타나겠지만, 계속해서 반복되진 않는다면 실행 시간은 약 O(NlogN)이 될 것이다.

항상 최선의 경우가 나타나려면 알고리즘 수행 전에 특수한 방법을 한 번 거친다면 가능할지도 모른다 하지만, 많은 알고리즘은 최악의 경우와 평균적인 경우가 같다. 가끔 이들이 달라서, 최악과 평균 두 경우가 따로 언급될 수도 있지만,..

<br>

### 공간 복잡도

알고리즘은 시간도 물론 중요하지만 메모리 혹은 공간이라고 하는 것도 신경 써야한다. 공간 복잡도는 시간 복잡도와 평행선을 달리는 개념인데, 크기가 n인 배열을 만든다고 하면, O(n)의 공간이 필요하고, n x n 크기의 2차원 배열을 만들고자 한다면 동일하게 O(n^2)의 공간이 필요한 것처럼 시간 복잡도와 유사하다. (시간 복잡도도 동일한 과정을 2번 반복한다면 O(2n)인 것과 비슷하다.)

아래 코드는 재귀 호출에 대표적인 예시인데, 이 코드는 시간 복잡도 O(n)과 공간 복잡도 O(n)을 사용한다.

```java
int sum(int n) {
  if (n <= 0) {
    return 0;
  }
  return n + sum(n-1);
}
```

```bash
sum(4)
	- sum (3)
		- sum (2)
			- sum (1)
				- sum (0) - exit
```

`sum(4)`를 실행하는 것을 예시로 든다면 총 `sum(0)`까지 가기 위해 `sum(4)`내부에서 총 4번의 함수를 호출하고 그 동안 메모리에는 각 재귀 호출에 대한 값을 4번 저장한다.









