# Sort - 2

> 그간 공부했던 정렬 알고리즘에 대한 정리와 추가적인 알고리즘에 대한 정리 2



<br>

# QuickSort

**Quick Sort** (퀵 정렬)은 **불안정 정렬**에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 **비교 정렬**에 속한다. 여기서 **불안정 정렬**이란, **안정성** (stable) 이라는 걸 먼저 이해해야하는데, 쉽게 설명하면 기존의 순서를 유지하는 정렬을 말한다. "응? 순서를 바꾸는게 정렬인데 기존의 순서를 유지한다는게 뭐지?"라고 생각할 수 있는데, 여기서의 순서는 동일한 값의 순서를 의미한다. 개발을 하다보면 리스트의 모든 값이 `unique` 하지 않기 때문에 중복된 값이 존재하기 마련인데, 이 때 중복된 값들 사이의 순서를 유지하는 것을 말한다.

<br>

```python
arr = [5, 2, 3, 1, 4, 5, 8]
print(sorting(arr))

> [1, 2, 3, 4, 5, 5, 8]
# 여기서 두 개의 5는 순서를 유지해야한다. 앞에 있는 5는 맨 처음 가장 앞에 있던 5여야한다는 걸 의미한다.
```

약간 간단하게 예를 생각하면, 우리가 입장을 하기 위해 줄을 섰는데 입장하시려면 나이 순서대로 입장 가능하세요. 라고 안내가 나오고 나이 순서대로 순서를 정하는데, 이 때 맨 앞에 있던 사람은 동일한 나이를 가진 사람들 사이에서도 맨 앞에 있어야한다는 것과 똑같다. (순서가 바뀌면 얼마나 억울하겠는가)

또한, 퀵 정렬은 **분할 정복** 알고리즘의 하나로 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법을 이용한다. **합병 정렬** (merge sort)와 달리 리스트를 비균등하게 분할한다. 여기서 **분할 정복** (divide and conquer) 방법이란, 문제를 작은 2개의 문제로 분리하고 각각 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략으로 대개 순환 호출을 이용하여 구현한다.

<br>

## Process

1. **피벗(pivot)** 선택한다. 여기서 피벗이란 리스트 안에 한 요소를 선택한다. (분할 하기 전 기준점을 의미)
2. **피벗**을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽 : 피벗의 작은 요소들, 오른쪽 : 피벗보다 큰 요소들)
3. 피벗을 제외한 왼쪽과 오른쪽 리스트를 정렬하는데, 분할된 부분에 리스트에 대해 순환 호출을 이용하여 정렬을 반복한다.
4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.



<br>

##  Python Code

**1.**

```python
def qsort(data):
    if len(data) <= 1:
        return data

    left, pivot, right = [], data[0], []

    for value in data[1:]:
        if value < data:
            left.append(value)
        else:
            right.append(value)

    return qsort(left) + [pivot] + qsort(right)
```

**2.**

```python
def qsort(data):
    if len(data) <= 1:
        return data

    center = len(data) // 2
    left, pivot, right = [], data[center], []

    for value in data[:center] + data[center+1:]:
        if value < pivot:
            left.append(value)
        else:
            right.append(value)

    return qsort(left) + [pivot] + qsort(right)
```



<br>

## Big-O

**시간 복잡도**는 **Code 1** 방식으로 진행하면, `O(n^2)`으로 계산된다. 그 이유는 초기 `pivot`을 중간이 아닌 맨 앞 원소로 잡아서 그런데, 이 경우에는 처음은 물론이고 파티션된 두 번째 정렬에서도 동일하게 맨 앞 원소부터 시작하는데, 시간 복잡도를 줄이기 위해서 **Code 2**에서는 가운데부터 시작하도록 수정하여 `O(n^2)` 보다 빠르게 한다. 이는 `O(nlogn)` 보다 더 빠르다고 알려져있다.

**공간 복잡도**는 순환 함수를 사용했지만, 배열의 공간 외에는 다른 공간을 더 크게 사용하진 않기 때문에 공간복잡도는 `O(n)` 이다.





<br>

# MergeSort

**MergeSort**은 병합 정렬이라 부르며, 분할 정복 방법을 사용하는 알고리즘이다. 여기서 분할 정복이 어떻게 쓰이냐면, 전체 데이터를 정확히 반으로 나누고 반으로 나눈 리스트로 또 반으로 나누어가는 과정을 반복하고 합치면서 정렬하는 알고리즘이다.

가장 큰 특징은 Stable Sort로 **안정 정렬**에 속한다. 이것도 코드 짜기 나름인 것 같지만, 분할 정복 알고리즘을 사용하기 때문에 리스트가 분할되어 다시 병합되는 과정을 거치면서 각 원소의 순서를 유지한 채로 정렬이 된다.



<br>

## Process

재귀 용법을 활용한 정렬 알고리즘이다.

1. 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
2. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
3. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.



예시를 들어 과정을 보면 다음과 같음

1. `[1, 9, 3, 2]`

2. `[1, 9], [3, 2]` : 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.

3. `[1], [9], [3], [2]` : 동일하게 두 부분으로 나눈다.

4. `[1, 9], [3], [2]` : `[1]`과 `[9]`를 비교하면서 병합

5. `[1, 9], [2, 3]` : `[3]`과 `[2]`를 비교하여 정렬 후 병합

6. `[1, 2, 3, 9]` : `[1, 9]`와 `[2, 3]`을 비교하며 정렬하여 병합



<br>

## Python Code

**1.**

```python
def merge(left, right):
    merged = list()
    left_point, right_point = 0, 0
    
    while len(left) > left_point and len(right) > right_point:
        if left[left_point] > right[right_point]:
            merged.append(right[right_point])
            right_point += 1
        else:
            merged.append(left[left_point])
            left_point += 1

    while len(left) > left_point:
        merged.append(left[left_point])
        left_point += 1
        
    while len(right) > right_point:
        merged.append(right[right_point])
        right_point += 1
    
    return merged

def mergesplit(data):
    if len(data) <= 1:
        return data
    medium = int(len(data) / 2)
    left = mergesplit(data[:medium])
    right = mergesplit(data[medium:])
    return merge(left, right)
```

**2.**

```python
def merge_sort(data):
    if len(data) <= 1:
        return data
    center = int(len(data) / 2)
    left, right = merge_sort(data[:center]), merge_sort(data[center:])
    return sort(left, right)

def sort(left, right):
    result = []
    if left is not None:
        result += left
    if right is not None:
        result += right

    for ix1 in range(len(result)-1):
        minimum = ix1
        for ix2 in range(ix1+1, len(result)):
            if result[ix2] < result[minimum]:
                minimum = ix2
        result[ix1], result[minimum] = result[minimum], result[ix1]

    return result
```



<br>

## Big-O

**시간 복잡도**는 평균 `O(nlogn)` 로 계산되고 최선, 최악 모두 동일하다. **공간 복잡도**는 `O(n)`이다. 공간복잡도는 생각보다 쉽게 계산되었는데, 원래 리스트를 절반 씩 분할하며 정렬하더라도 원래의 사이즈인 `n` 이하로 분할되고 유지되기 때문에 공간 복잡도는 `O(n)`이다.





<br>

# HeapSort

완전 이진 트리를 기본으로 하는 힙(Heap) 자료 구조를 기반으로한 정렬 방식으로 여기서 완전 이진 트리란, 삽입할 때 왼쪽부터 차례대로 추가하는 이진 트리를 말한다. 힙 소트는 불안정 정렬에 속하는데 그 이유는 입력된 순서에 따라 왼쪽부터 차례대로 추가되지만, 순서가 바뀌게 되면서 자식 노드와 부모 노드의 위치로 인해 순서가 뒤죽박죽 된다.



<br>

## Process

1. 최대 힙을 구성한다.
2. 최대 힙을 구성하면 힙의 루트에는 가장 큰 값이 존재하는데, 루트의 값을 마지막 요소와 바꾼 후 힙의 사이즈를 하나 씩 줄여 나간다. (여기서 제거한 루트의 가장 큰 값을 추가해가면서 정렬하는 방식이다.)
3. 힙의 사이즈가 1보다 크면 위 과정 반복



<br>

## Python Code

**1.** python 내장 모듈인 heapq를 이용한 방법 

```python
import heapq

def heap_sort(data):
    heap = []
    for e in data:
        heapq.heappush(heap, e)
    result = []
    while heap:
        result.append(heapq.heappop(heap))
```



<br>

## Big-O

**시간복잡도**는 최선, 평균, 최악 모두 `O(nlogn)`이고, **공간복잡도**는 `O(n)`인 알고리즘에 속한다.


<br>


## Reference

* [퀵 정렬이란 - heejeong Kwon](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)