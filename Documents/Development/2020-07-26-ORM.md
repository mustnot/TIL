# ORM

**ORM** (Object-Relational Mapping)으로 객체-관계 매핑으로 쉽게 말하면, 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것으로 말할 수 있다. 객체지향 프로그래밍에서는 **클래스**를 사용하고, 관계형 데이터베이스는 **테이블**을 사용하는데, 개발하다보면 느끼는건데, 객체 모델과 관계형 모델 간의 불일치가 존재하기 마련이다. (사실 이 말에 대해 바로 이해하기 어려웠는데, 내가 지금까지 데이터베이스와 연결해서 개발한 코드들을 살펴보면 100% 일치하기보다는 7~80% 일치하거나 그에 미치지 못한 수준의 클래스가 생성되어 작동되고 있는 걸 볼 수 있었다) 그렇기 때문에 **ORM**이 생겨났고, 이런 ORM은 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.

<br>

## 장단점

**장점**

* **객체 지향적인 코드**로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
    * ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메서드)로 데이터를 조작할 수 있어 개발자가 객체 모델로 프로그래밍하는 데 집중할 수 있도록 도와준다. 
    * 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다. 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
    * SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
* **재사용 및 유지보수**의 편리성이 증가한다.
    * 객체 지향적인 성격을 띄기에 ORM은 독립적으로 작성되어 있어 해당 객체들을 재활용 할 수 있다.
    * 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다. 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
* DBMS에 대한 **종속성이 줄어든다.**
    * 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와 코드의 객체지향 모델 사이의 간격을 좁힐 수 있다.
    * 대부분 ORM 솔루션은 DB에 종속적이지 않다. 종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다. 
    * 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.

**단점**

* **완벽한 ORM** 으로만 서비스를 구현하기가 어렵다.
    * 사용하기에는 매우 편리할 수도 있지만, 그렇기에 설계에 매우 신중해야한다. 특히 프로젝트의 복잡성이 커질수록 완벽한 ORM으로 모든 서비스를 구현하기 어렵기 때문에 설계 난이도 또한 올라갈 수 있다.
    * 잘못 구현된 경우에는 작동에는 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다. 일부 자주 사용되는 **대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우**가 있다.
    * DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.) 
* 프로시저가 많은 시스템에선 **ORM의 객체 지향적인 장점**을 활용하기 어렵다. 
    * 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.

<br>

## Flask SQLAlchemy

> MySQL과 SQLAlchemy를 함께 사용하려면 먼저 MySQL 설치하고 원하는 DB와 Table을 생성한 후에 이용 가능하다. (당연한 말이지만, 나는 안그래도 되는줄 알았다 ㅎ..ㅎ)

```python
from flask import Flask, abort, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = "mysql://user:psswd@localhost/flask_db"
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False 

db = SQLAlchemy()
db.init_app(app)

class User(db.Model):
    uid = db.Column(db.String(36), primary_key=True)
    name = db.Column(db.String(50), nullable=False)
    email = db.Column(db.String(100), default="")
    create_dtime = db.Column(db.DateTime, nullable=False, default=datetime.now())

@app.route('/user/<string:uid>')
def getUserInfo(uid):
    user = User.query.get(uid)
    rv = {
        'name': user.name,
        'email': user.email,
        'create_dtime': user.create_dtime
    }
    return jsonify(rv)

@app.route('/ping')
def ping():
    return 'pong'

if __name__ == "__main__":
    app.run(host='127.0.0.1', port=5000)
```

개발자라면 기승전코드라고 코드 먼저 보고 싶어할 수 있을 것 같아서 가장 상단에 코드 먼저 쓰고 설명 시작 (나는 되도록이면 코드 먼저 보는게 오히려 이해가 더 쉽다고 생각한다) 지저분하지만 실습을 위한 코드라 생각하시고 넘어가셨으면 좋겠습니다 !

먼저 가장 위를 보면 `app.config`에 `SQLAlCHEMY_DATABASE_URI`에 `mysql` 이 쓰여있는데, 테스트 코드라 위와 같이 작성했지만 보안에 매우 안 좋으니 참고만 하시고 환경 변수를 이용하거나 `config` 파일을 이용하여 받아오는 것을 추천드립니다. 아무튼, 위처럼 데이터베이스와 `flask app` 을 서로 연결하면 우선 연결이 끝났다고 보면 된다. 

다음으로 `Class` 작성인데, 대체로 아래의 형식처럼 작성된다고 보면 된다. 클래스명이 곧 테이블명이 되고 아래의 컬럼들이 해당 테이블의 각 컬럼을 의미한다. 만약에 `class` 내에 컬럼을 추가했는데, `MySQL` 내 테이블에 컬럼을 추가하지 않았다면 에러가 나니 서로 동일한지 항상 확인이 필요하고 작성시 항상 체크가 필요하다.

```python
class TableName(db.Model):
		column1 = db.Column(db.String(100), primary_key=True)
    column2 = db.Column(db.Integer(100), default=0)
```

이렇게 작성된 `class`를 이용하는 건 매우 쉽다. 코드를 보면 알겠지만, `primary_key`인 `uid`를 이용하여 데이터를 `SELECT`하는 것도 단순하게 `User.query.get(uid)` 만으로 바로 가져올 수 있어 처음 사용해본 나도 굉장히 편리하다는 걸 알 수 있었다. (지금까지 대체로 모든 쿼리를 작성해서 코드를 짜왔던 나는.. 정말 신세계를 잠시나마 경험했다)ㅇ



<br>

## Reference

1. [ORM이란 - heejeong Kwon](