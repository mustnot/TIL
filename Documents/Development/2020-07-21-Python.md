# Python Developer Question

> 파이썬 개발한지 거의 2년이 다 되어가는데, 늘 사용하던 것들도 왜 사용하는지 어떤 이유로 이런 코드가 더 유용한지에 대해 정확히 모를 때가 있어서 리마인드 겸 정리하기 위해 "Hire the Top 3% of Freelance Python Developers" 라는 글을 읽고 내용 정리와 내 생각을 적어봄



## Q : Why use function decorators? Give an example.

파이썬 데코레이터(Decorator)는 본질적으로 함수 또는 클래스 정의를 수정하거나 확장하는데 사용되는 호출 가능한 파이썬 객체로, 데코레이터를 사용하는 이유 중 하나는 정의된 하나의 데코레이터가 여러 함수(또는 클래스)에 적용될 수 있다는 점이다. 가장 대표적인 예시로 Flask는 데코레이터를 이용해 웹 애플리케이션에 새 엔드 포인트를 추가하는 데 사용하며 기본적인 방법인 함수를 만들고 엔드 포인트를 매핑하는 번거로운 작업을 데코레이터 하나로 충족시켜준다. (Flask 개발자로서 이건 정말 편하다고 느낀다. Django 였다면, 하나하나 엔드포인트를 지정해줘야했을텐데 !) 데코레이터는 위 예시 외에도 클래스 또는 함수에 동기화, 형식 적용, 로깅 또는 사전 / 사후 조건 추가가 가능하다. 

내가 직접 만들어보고 잘 사용하고 있는 데코레이터는 일부 리턴 폼을 아름답게 내가 원하는 형식으로 변경시켜주는 데코레이터와 데이터베이스에서 데이터를 가져올 때 얼마나 시간이 걸리는지에 대해 계산해주는 데코레이터를 자주 사용한다. 물론 이외에도 Flask에서 여러 데코레이터를 사용하고 있다.

<br>

## Q : What are lambda expressions?

Lambda 표현식은 한 줄로 일종에 이름이 정의되지 않는 함수를 만드는 간단한 기법이다. 어떻게 보면 AWS에 있는 Lambda와 동일한건가라고 생각할 수도 있는데 내 생각이지만 거의 동일한 기능을 제공한다. 다만 AWS Lambda는 이름이 정의되지 않는 것이 아닌 서버가 정의되지 않은 함수라고 생각하면 더 좋을 것 같다고 생각한다. (그저 내 생각이다)

**인라인 함수**라는 특성으로 기존 공식 함수 선언보다 더 읽기 쉽고 간결한 코드가 생성된다.

```python
lambda x, y: x + y
```

하지만 단점도 존재하는데, 인라인 함수라는 특성 상 여러 곳에서 참조가 불가능하다는 단점이 있다. 무슨 말이냐면, A 라는 함수 내에서 인라인으로 lambda 함수를 이용했다면 B 라는 함수 내에서는 A에서 사용한 lambda 함수는 사용할 수가 없다. 그래서 인라인 함수라는 점에서 적용 범위에 있어서는 매우 제한적이다.

<br>

## Q : Consider the two approaches below for initializing an array and the arrays that will result. How will the resulting arrays differ and why should you use one initialization approach vs. the other?

 ```python
> x = [[1, 2, 3, 4]] * 3
> x
> [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]
> y = [[1, 2, 3, 4] for _ in range(3)]
> y
> [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]
 ```

`x, y` 리스트만 보면 둘 다 동일하게 `[1, 2, 3, 4]` 3개를 원소로 갖고 있는데, 3개의 차이점은 `x`의 경우에는 `[1, 2, 3, 4]` 라는 동일한 객체를 3번 반복한 것으로 3개의 원소 모두 동일한 객체를 바라보고 있고, `y`의 경우에는 3개의 원소를 각각 새로 생성하여 리스트 안에 포함시켰기 때문에 3개의 객체는 모두 다른 객체로 볼 수 있다.

```python
> x[0][3] = 99
> x
> [[1, 2, 3, 99], [1, 2, 3, 99], [1, 2, 3, 99]]
> y[0][3] = 99
> y
> [[1, 2, 3, 99], [1, 2, 3, 4], [1, 2, 3, 4]]
```

리스트의 원소의 값 중 하나를 99로 변경한 결과인데, `x, y`의 결과가 다른 것을 볼 수 있다 .이처럼 `x`의 경우에는 모두 동일한 객체이기 때문에 하나의 객체가 변경되면 동일한 다른 객체 역시도 변경되는 현상이 있다. 그 반대로 `y`의 경우에는 각기 다른 객체이기 때문에 첫번 째 리스트의 원소만 변경되었다.

<br>

## Q : What will be printed out by the second append() statement below?

```python
def append(list=[]):
  list.append(len(list))
  return list

> append(['a', 'b'])
['a', 'b', 2]
> append()
[0]
> append()
??
```

두 번째 `append()`의 결과는 처음 `append()`의 결과와 아무래도 똑같다고 생각했다. (나도 그랬다) 하지만 결과는 `[0, 1]`로 나온다. 왜 그럴까라고 물어보면 나는 몰랐다. 나는 저렇게 초기화를 시켜본 적도 없거니와 저렇게 써본적도 없어서이다. 원인은 함수 인수의 기본값이 표현식일 경우에 생기는 문제인데, 몇 번 시도해보니 표현식이 아니여도 동일한 현상은 나타난다. (아래 예시 코드)

```python
default_list = []
def append(list=default_list):
  list.append(len(list))
  return list
```

그럼 현상에 대한 정확한 원인은 무엇이냐면 **함수는 호출 될 때마다 표현식을 단 한 번만 계산한다**는 점인데, 일단 리스트 인수가 빈 배열로 초기화되면, 인수가 지정되지 않은 이후에 호출되는 경우에는 원래 초기화되었던 동일한 배열을 계속 사용하기 때문에 이러한 예상할 수 없는 동작이 발생하게 된다. 아래는 결과이다.

```python
> append()
[0]
> append()
[0, 1]
> append()
[0, 1, 2]
> append()
[0, 1, 2, 3]
```

