# ☸ Kubernetes

지금까지 사용했던 **도커**의 경우 하나의 서비스를 컨테이너로 가상화시켜 배포를 하기 위해 자주 사용되지만, 보다 많은 서비스를 운영하는 기업의 경우 이것들을 모두 일일이 배포하고 운영하는 역할을 하지 않는다. 그렇기 때문에 여러 컨테이너를 관리하는 **컨테이너 오케스트레이터**라는 솔루션을 이용한다.



### Introduction

> 📌 요약하면, 구글에서 공개한 쿠버네티스는 컨테이너화된 서비스를 관리하고, 구성과 자동화를 용이하게 해주는 누구나 쉽게 이용할 수 있는 오픈 소스 플랫폼이다.

쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장 가능한 오픈소스 플랫폼이다. 쿠버테니스는 선언적 구성과 자동화를 용이하게 해주며, 크고 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.

쿠버네티스라는 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래하여 구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화했다. 쿠버네티스는 프로덕션 워크로드를 대규모로 운영하는 15년 이상의 구글 경험과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.

<br>

### VM vs Container

> 격리된 환경의 Container 운영 환경을 다음 시스템에 연결해보는 것도 좋을 것 같다.

먼저 왜 쿠버네티스를 사용해야하는지 알아보기 전 컨테이너를 이용하면서 생긴 이점이 무엇인지 살펴봐야할 것 같다. 도커를 공부하면서 느낀 컨테이너의 장점은 여러 가지가 있는데, 나는 그 중에 OS와 격리되어 실행되고 각 격리된 환경들이 서로 연결될 수 있다는 점이였다.

1. **빠른 애플리케이션 생성과 배포 :** VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적인데, 쉽게 생각하면 VM 이미지 생성할 때 오래 걸리는 설정 과정에 대해 생각해보면 될 것 같다.
2. **지속적인 개발, 통합 및 배포 :** 주기적으로 안정된 컨테이너 이미지를 빌드하고 배포할 수 있고, 문제가 생겼을 경우 빠르고 쉽게 롤백할 수 있다.
3. **개발과 운영의 관심사 분리 :** 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에 애플리케이션이 인프라스트럭처에서 분리된다. (💡처음에는 이해하지 못했지만, 도커를 이용하다보면서 느낀점인데 지금까지 서비스를 운영하다보면 마지막 배포 단계에서 어떤 일이 벌어질지 상상하기 어렵다. 운영 시점과 개발 시점의 차이가 존재하기 때문인데, 도커를 이용하면 이미 에러 없이 완성된 이미지를 배포하면 되기 때문에 안정성이 높다고 생각한다)

4. **가시성 :** OS 수준의 정보와 메트릭에 머무르지 않고, 어플리케이션 자체의 상태와 여러 신호(로그)를 볼 수 있다.
5. **개발, 테스트 및 운영 환경에 걸친 일관성 :** 어떤 운영 환경에서든 동일한 이미지를 통해 배포 운영 할 수 있다. (이 부분이 가장 좋았다.)
6. **클라우드 및 OS 배포판 간 이식성 :** Ubuntu, RHEL, CoreOS, On-premis 등 어디에서든 구동 가능하다.
7. **리소스 격리 :** 리소스가 OS와 분리되어 어플리케이션 자체의 성능만을 예측할 수 있다.
8. **자원 사용량, 리소스 사용량 :** 고효율 고집적

<br>

### Why kubernetes?

> 사용해보진 않았지만 읽은 것만으로도 self-healing 기능이 정말로 좋은 것 같다. 

위 처럼 **컨테이너**는 VM과 달리 어플리케이션을 포장(패키징)하고 실행하는 좋은 방법이다. 하지만, 운영 환경에서 어플리케이션을 실행하는 컨테이너를 관리하고, 중단 시간이 존재하는지 확인하거나 혹은 컨테이너가 다운되었다면 다른 컨테이너를 재시작해야하는데 이런 문제를 시스템에 의해 처리한다면 더 좋지 않을까? 라는 이유에서 필요한 것이 바로 **쿠버네티스**이다.

쿠버네티스는 분산 시스템을 탄력적으로 운영하기 위한 프레임워크를 제공하고 어플리케이션의 확장과 장애 조치를 처리하고, 배포 규칙 등의 설정을 제공한다.

- **서비스 디스커버리와 로드 밸런싱** 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션** 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.
- **자동화된 롤아웃과 롤백** 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
- **자동화된 빈 패킹(bin packing)** 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)** 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- **시크릿과 구성 관리** 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다

<br>

<br>

## Docs

> 📌[Kubernetes 문서](https://kubernetes.io/ko/docs/concepts/overview/)
>
> 아무래도 Kubernetes 공식 문서의 내용을 참고하여 공부해야할 것 같아 본문 내용을 참고하며 정리했다.

<br>

### 개요

**쿠버네티스**는 컨테이너화된 워크로드와 서비스를 관리하기 위한 **이식성**과 **확장성**을 가지고 있는 오픈소스 플랫폼으로 선언적 구성과 자동화를 모두 지원한다. 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있으며 쿠버네티스 서삐스, 지원 그리고 도구들이 광범위하게 제공된다.

<br>

#### 쿠버네티스 클러스터

쿠버네티스를 배포하면 클러스터를 얻는다. 이러한 클러스터는 컨테이너화된 어플리케이션을 실행하는 **노드**라고 하는 워커 머신의 집합을 갖는다. (모든 클러스터는 최소 1개의 워커 노드를 가지고 있다)

**워커 노드**는 어플리케이션의 구성 요소인 파드(Pod)를 호스트하는데, **컨트롤 플레인**은 워커 노드와 클러스터 내 파드를 관리한다. 프로덕션 환경에서 일반적으로 컨트롤 플레인이 여러 컴퓨터에 걸쳐 실행되고, 클러스터는 일반적으로 여러 노드를 실행하므로 내결함성과 고가용성이 제공된다.

<br>

##### 컨트롤 플레인 컴포넌트

컨트롤 플레인 컴포넌트는 클러스터에 전반적인 결정(예, 스케줄링)을 수행하고 클러스터 이벤트를 감지하고 반응한다. 컨트롤 플레인 컴포넌트는 클러스터 내 어떠한 머신에서든지 동작할 수 있는데, 간결성을 위하여 구성 스크립트는 보통 동일 머신 상에 모든 컨트롤 플레인 컴포넌트를 구동시키고 사용자 컨테이너는 해당 머신 상에 동작시키지 않는다.
(다중-마스터-VM 설치 예제: [고가용성 클러스터 구성하기](https://kubernetes.io/docs/admin/high-availability/) 참고)

* **kube-apiserver :** API 서버는 쿠버네티스 API를 노출하는 쿠버네티스의 <u>컨트롤 플레인</u> 컴포넌트이다. API 서버는 쿠버네티스 플레인의 프론트 엔드이다. 쿠버네티스 API 서버의 주요 구현은 [kube-apiserver](https://kubernetes.io/docs/reference/generated/kube-apiserver/) 로 kube-apiserver는 수평으로 확장되도록 디자인되었다. 즉 더 많은 인스턴스를 배포해서 확장할 수 있는데 여러 api 인스턴스를 실행하고 인스턴스 간 트래픽을 균형있게 조절할 수 있다.
* **etcd :** 모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성, 고가용성 키-값 저장소로 쿠버네티스 클러스터에서 etcd를 저장소로 사용한다면 이 데이터를 백업하는 계획이 필수적이니 [참고](https://etcd.io/docs/)하자.
* **kube-scheduler :** 노드가 배정되지 않은 새로 생성된 Pod를 감지하고 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트
* **kube-controller-manager :** 컨트롤러를 구동하는 <u>마스터 상의 컴포넌트</u>이다. 논리적으로 각 컨트롤러는 개별 프로세스이지만, 복잡성을 낮추기 위해 모두 단일 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다.
  * 노드 컨트롤러 : 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.
  * 레플리케이션 컨트롤러 : 시스템의 모든 레플리케이션 컨트롤러 오브젝트에 대해 알맞은 수의 파드들을 유지시켜 주는 책임을 가진다.
  * 엔드포인트 컨트롤러 : 엔드포인트 오브젝트를 채운다(즉, 서비스와 파드를 연결시킨다.)
  * 서비스 어카운트 & 토큰 컨트롤러 : 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다

* **cloud-controller-manager :** 클라우드별 컨트롤 로직을 포함하는 쿠버네티스 컨트롤 플레인 컴포넌트로 생성하는 클러스터를 클라우드 공급자의 API에 연결하고, 해당 클라우드 플랫폼과 상호작용하는 컴포넌트이다.
  다음 컨트롤러들은 클라우드 제공 사업자의 의존성을 가질 수 있다.
  * 노드 컨트롤러: 노드가 응답을 멈춘 후 클라우드 상에서 삭제되었는지 판별하기 위해 클라우드 제공 사업자에게 확인하는 것
  * 라우트 컨트롤러: 기본 클라우드 인프라에 경로를 구성하는 것
  * 서비스 컨트롤러: 클라우드 제공 사업자 로드밸런서를 생성, 업데이트 그리고 삭제하는 것

<br>

##### 노드 컴포넌트

노드 컴포넌트는 동작 중인 Pod(파드)를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작한다.

* **kubelet : ** 클러스터의 각 노드에서 실행되는 에이전트. Kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다. Kubelet은 쿠버네티스를 통해 생성되지 않는 컨테이너는 관리하지 않는다.
* **kube-proxy :** 클러스터의 각 노드에서 실행되는 네트워크 프록시로, 쿠버네티스의 서비스 개념의 구현부이다. 노드의 네트워크 규칙을 유지 관리한다. 이 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 해준다.
* **컨테이너 런타임 :** 컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.
* **DNS :** 여타 애드온들이 절대적으로 요구되지 않지만, 많은 예시에서 필요로 하기 때문에 모든 쿠버네티스 클러스터는 [클러스터 DNS](https://kubernetes.io/ko/docs/concepts/services-networking/dns-pod-service/)를 갖추어야만 한다. 클러스터 DNS는 구성환경 내 다른 DNS 서버와 더불어, 쿠버네티스 서비스를 위해 DNS 레코드를 제공해주는 DNS 서버다.
* **웹 UI (대시보드) :** 대시보드는 쿠버네티스 클러스터를 위한 범용의 웹 기반 UI다. 사용자가 클러스터 자체뿐만 아니라 클러스터에서 동작하는 애플리케이션에 대한 관리와 문제 해결을 할 수 있도록 해준다.
* **컨테이너 리소스 모니터링 : ** [컨테이너 리소스 모니터링](https://kubernetes.io/ko/docs/tasks/debug-application-cluster/resource-usage-monitoring/)은 중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시계열 매트릭스를 기록하고 그 데이터를 열람하기 위한 UI를 제공해 준다.
* **클러스터-레벨 로깅 :** 클러스터-레벨 로깅 메커니즘은 검색/열람 인터페이스와 함께 중앙 로그 저장소에 컨테이너 로그를 저장하는 책임을 진다

> 쓰다보니 너무 길어질 것 같아서 진행하면서 정리

