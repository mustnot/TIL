# Execution Plan

> 📌 Database에서 실행 계획(Execution Plan)에 대해 공부한 내용

DBMS의 쿼리 실행에 같은 결과를 만들어 내는 데 한가지 방법만 있는 것은 아니다. 아주 다양한 방법이 존재하고 그 중에 어떤 방법이 최적이고 최소 비용으로 동작할지 결정해야하는데, DBMS에는 쿼리를 최적으로 실행하기 위한 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보 등을 참조하여 이런 기본 데이터를 비교해 최적의 실행 계획을 수행하는 작업이 필요하다. 이런 역할은 DBMS에서는 옵티마이저 기능이 담당한다.

MySQL에서는 `EXPLAIN`이라는 명령으로 쿼리의 **실행 계획**을 확인할 수 있으며 많은 정보가 출력된다.

<br>

## 실행 계획이란?

어떤 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분으로 알려져 있으며, 옵티마이저가 만들어 내는 실행 계획을 이해하는 것 또한 상당히 어려운 부분이다. 하지만 그 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고 더욱 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.



#### 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 3가지로 나눌 수 있다.

1. SQL 파싱 (SQL 파서) : 사용자로부터 요청된 SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리
2. 최적화 및 실행 계획 수립 : SQL 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
   * 불필요한 조건의 제거 및 복잡한 연산의 단순화 등 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정하고 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정, 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정한다.
3. 2에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.



### 옵티마이저의 종류

옵티마이저는 데이터베이스 서버에 두뇌와 같은 역할을 담당하고 있는데, 옵티마이저는 현재 대부분의 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based Optimizer, CBO) 방법과 예전 오라클에서 많이 사용했던 규칙 기반 최적화 방법 (Rule-based Optimizer, RBO) 으로 크게 나눌 수 있다.

* 규칙 기반 최적화 : 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
* 비용 기반 최적화 : 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출




### 실행 계획 분석

MySQL에서 쿼리의 실행 계획을 확인하려면 `EXPLAIN` 명령을 사용하면 된다. 아무런 옵션 없이 EXPLAIN 명령만 사용하면 기본적인 쿼리 실행 계획만 보인다. 하지만, `EXPLAIN EXTENDED`나 `EXPLAIN PARTITIONS` 명령을 이용해 더 상세한 실행 계획을 확인할 수 있다.

`EXPLAIN` 명령은 다음과 같이 `EXPLAIN` 키워드 뒤에 확인하고 싶은 `SELECT` 쿼리 문장을 작성하면 된다.

```mysql
EXPLAIN
SELECT uid
FROM user
WHERE account_type = "google";
```

이렇게 실행하면 쿼리 문장의 특성에 따라 표 형태로 된 1줄 이상의 결과가 표시된다. 표의 각 라인(레코드)은 쿼리 문장에서 사용된 테이블(서브 쿼리로 임시 테이블을 생성한 경우 임시 테이블까지 포함)의 개수만큼 출력된다. 실행 순서는 위에서 아래로 순서대로 표시된다. 출력된 실행 계획에서 위쪽에서 출력된 결과일수록 쿼리의 바깥 부분이거나 가장 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 혹은 나중에 접근한 테이블에 해당된다.

![F2371513-ED54-4E38-AAA3-8481D6EA880D](https://user-images.githubusercontent.com/52126612/97080187-9478fe80-1634-11eb-8191-657f9e1c9fcf.png)

### 컬럼 정보

* `select_type` : 각 단위 `SELECT`가 어떤 타입의 쿼리인지 표시되는 컬럼
  * `SIMPLE` : 가장 단순한 `SELECT` 쿼리인 경우, `SIMPLE`로 표기된다.
  * `PRIMARY` : `UNION`이나 서브 쿼리가 포함된 `SELECT` 쿼리의 실행 계획에서 가장 바깥에 있는 단위 쿼리는 `select_type`이 `PRIMARY`로 표시된다.
  * `UNION` : `SELECT` 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 `SELECT` 쿼리의 `select_type`은 `UNION`으로 표시된다.
  * .. 너무 많다



## Hint을 이용한 실행 계획 제어

1. `USE INDEX` : 사용자가 원하는 인덱스가 있는 경우 사용하며, 힌트가 항상 적용되는 것은 아니기에 옵티마이저가 잘못된 인덱스를 선택하여 사용하는 경우 유용하다.
2. `IGNORE INDEX` : 제외하고자 하는 인덱스가 있는 경우 사용하는데, 이것 역시 항상 적용되는 것은 아니다.
3. `FORCE INDEX` : 사용하기 원하는 인덱스가 있는 경우 사용하며, 옵티마이저가 선택할 수 없는 인덱스라고 판단되는 경우 선택한 인덱스를 무시하고 Table Full-Scan을 한다.

