# Redis

> 📌 써보면서도 왜 이걸 쓰는지 정확히 공부해야할 것 같다.

Redis (Remote Dictionary Server) 는 In-Memory 데이터베이스로 모든 데이터를 메모리에 저장과 조회가 빠른 **비관계형 데이터베이스**이다. 키-값 데이터 구조를 갖고 있으며, 다양한 데이터 구조 집합을 제공하여 사용자 정의 어플리케이션을 손쉽게 생성할 수 있다.

<br>

## Redis vs Memcached

**Redis**와 같은 메모리 캐싱 시스템으로 대표적으로 비교되는 것으로 **Memcached**가 있다. Redis를 사용하는 많은 이유를 설명하는 글의 대다수가 Memcached 보다 장점이 많다는 점을 설명하는 글이 많아 자세한 Memcahed에 장/단점을 파악하기 어려웠다.

**Memcached**도 역시 오픈 소스로 03년 개발되어 처음에는 펄(Perl)로 작성되었지만 현재는 C로 재개발되었다. Redis와 동일하게 메모리에 데이터를 저장하는 방식을 이용하는데, In-Memory 특징상 서버가 다운되면 저장되어 있던 데이터가 지워지는 휘발성을 갖고 있다.

반면, Redis의 경우에는 Memcached와 동일하게 In-Memory 데이터베이스임에도 불구하고 복구할 수 있는 솔루션을 제공하여 서버가 다운되더라도 이전에 저장해놓은 데이터를 다시 사용할 수 있는 환경을 제공하는 안전성이 있다. 또한 Redis는 문자열 뿐만 아니라 `List, Set, Sorted Set, Hash, Bit Array, Hyperloglogs` 등 다양한 데이터 구조를 지원하여 보다 쉽게 정보를 제공할 수 있다.

Redis만의 특징을 정리하면 다음과 같다.

1. **다양한 데이터 구조** : `String, List, ...` 등 다양한 데이터 구조를 지원한다.
2. **Snapshots** : In-Memory 데이터베이스라는 특성에서 벗어나 데이터를 디스크에 저장하여 파일로 보관이 가능하다. 장애 상황시 복구에 사용된다.
3. **복제** : Mast-Slaves 구조로 여러 개의 복제본을 만들 수 있어 데이터 읽기 구조를 확장하여 높은 가용성 클러스터를 제공한다.
4. **트랜잭션** : 데이터베이스 상태를 변경시키는 작업 단위를 의미하는 트랜잭션의 특징을 모두 갖고 있다.
5. **Pub / Sub Message** (Publish:발행 / Sub:구독) : 두 가지 방식의 메세지를 구분하여 검색이 가능하다. 따라서 높은 성능을 요구하는 채팅, 실시간 스트리밍, SNS 피드 그리고 서버상호 통신에 사용할 수 있다.

6. **위치 기반 데이터 타입 지원** : Redis는 실시간 위치 기반 데이터를 지원하여, 두 위치의 거리를 찾거나 사이에 있는 요소 찾기 등의 작업을 수행할 수 있다. 이를 활용한 지도 기반의 고성능 서비스를 제공할 수 있다.

이처럼 Redis가 Memcached 보다 월등히 뛰어난 것처럼 보이나, Redis의 구조적으로 `싱글 쓰레드` 라는 단점이 있어, 1번에 1개의 명령만 실행 가능하다. 그래서, Memcached에서 사용하는 `멀티 쓰레드` 방식과 달리 모든 데이터를 가져온다던가 삭제한다는 명령어를 실행하게 되면 Memcached와 근본적으로 속도 차이가 존재하게 된다.

<br>

### Commands

Redis를 처음 사용할 때 느낀점은 "매우 간단하다"라는 느낌이였는데, 딥하게 들어가면 사용법이 더 복잡해지겠지만, 간단한 응용 수준의 명령어는 매우 단순하고 직관적이라는 것을 느꼈다.

#### set, get

```bash
> set today 2020-11-02
OK
> get tody
"2020-11-02"
```

#### incr

위에서 `set`한 결과를 보면 알겠지만, Redis는 모든 값을 String 유형으로 저장한다. 그렇다면 정수형의 데이터를 저장했다면 매번 정수형으로 변환하여 작업해야하는가? 라는 생각이 들었는데, 그건 맞으나 만약 단순히 숫자를 증가시키고 감소시킨다면, `incr` 명령어로 가능하다.

```bash
> set number 1000
OK
> incr number 5
(integer) 1005
> get number
"1005"
> incrby number -5
(integer) 1000
> get number
"1000"
```

보면 알겠지만, `incr`, `incrby` 두 명령어로 수를 증가시키거나 감소시킬 수 있는데, 그 과정에서 값은 integer 형태로 변경되지만 다시 값을 가져올 때에는 string 형태로 변경되어 출력되는 걸 볼 수 있다.

#### nx, xx

키가 이미 존재하거나, 존재하지 않는 경우 데이터를 저장하게 하는 옵션이다.

```
> set newkey newval nx
OK
> set newkey newval xx
OK
```