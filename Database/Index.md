# Index

> 📌 속도를 개선하기 위해 사용하는지는 알고 있지만, 정확히 어떤 방식으로 속도를 개선한지 이해하기 위해 공부

기본적인 개념을 살펴보면 다음과 같다. **인덱스(Index)**는 데이터베이스 분야에서 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다. 인덱스는 테이블 내의 1개의 컬럼 혹은 여러 개의 컬럼을 이용하여 생성될 수 있는데, 고속의 검색 뿐만 아니라 레코드 접근과 <u>효율적인 순서 매김 동작에 대한 기초</u>를 제공한다. 인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 적게 할애되는데, **관계형 데이터베이스**에서는 인덱스란 테이블 부분에 대한 하나의 사본 역할을 한다고 볼 수 있다. 

> ℹ️ 인덱스를 저장하기 위해 디스크 공간이 테이블을 저장하는 디스크 공간보다 적게 할애되는 이유는 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다.

요약하면 데이터베이스 안의 레코드를 처음부터 풀 스캔하지 않고, **<u>B+ Tree</u>**로 구성된 구조에서 Index 파일 검색으로 속도를 향상시키는 기술이다.

그렇다면, 속도 향상을 위해서 무조건 많이 설정하면 좋은걸까? 그건 아니다. 인덱스는 하나 혹은 여러 개의 컬럼에 대해 설정할 수 있고, 단일 인덱스를 여러 개 생성할 수도, 여러 컬럼을 묶어 복합 인덱스를 설정할 수도 있다. 그러나 무조건 많이 설정한다고 검색 속도를 월등히 높여주는 것은 아닌데, 인덱스는 데이터베이스 메모리를 사용하여 테이블 형태로 저장하기 때문에 개수와 저장 공간은 비례한다.

<br>

### Index의 원리

테이블 생성시 3개의 파일이 다음과 같이 생성된다.

* FRM : 테이블 구조 저장 파일
* MYD : 실제 데이터 파일
* MYI : Index 정보 파일 (Index 사용 시 생성된다.)

이렇게 생성된 3개의 파일 중 인덱스를 원하는 컬럼에 주게 되면, 위와 같이 초기에 생성된 3개의 파일 중 MYI에 해당 컬럼을 색인화하여 저장한다. 물론 인덱스를 사용하지 않는 경우 MYI 파일은 비어 있다. 그래서 SELECT 쿼리로 INDEX가 사용하는 쿼리를 사용시 해당 TABLE을 검색하는 것이 아닌 빠른 Tree로 정리해둔 MYI 파일의 내용을 검색한다.

> 📌 공부하다가 갑자기 DML, DCL, DDL 의 차이가 헷갈려서 정리
>
> * DML : Data Manipulation Language 데이터 조작어로 SELECT / INSERT / UPDATE / DELETE 등이 포함
> * DDL : Data Definition Language 데이터 정의어로 CREATE / ALTER / DROP / RENAME / TRUNCATE 등
> * DCL : Data Control Language 데이터 제어어로 GRANT / REVOKE
> * TCL : Transaction Control Language 트랜잭션 제어어로 COMMIT / ROLLBACK / SAVEPOINT

만약 인덱스를 사용하지 않은 SELECT 쿼리라면 해당 TABLE 을 Full Scan 하여 검색한다.

<br>

### Index의 단점

* 인덱스 생성시 .mdb 파일 크기가 증가한다.
* 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
* 인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 저하한다.
* 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로 성능에 영향을 미친다.

<br>

### Index의 사용 상황

#### 사용하면 좋은 경우

1. Where 절에서 자주 사용되는 Column
2. 외래키가 사용되는 Column
3. Join에서 자주 사용되는 Column

<br>

#### 피해야하는 경우

1. Data 중복도가 높은 컬럼

2. DML이 자주 일어나는 컬럼

   * INSERT : 기존 Block에 여유가 없을 경우, 새로운 Data가 입력된다.

     -> 새로운 Block을 할당 받은 후 Key를 옮기는 작업을 수행한다.

     -> Index split 작업 동안, 해당 Block의 Key 값에 대해 DML이 블로킹된다. (대기 이벤트 발생)

   * DELETE :

     * Table에서 Data가 Delete 되는 경우 : Data가 지워지고, 다른 Data가 그 공간을 사용한다.

     * Index에서 Data가 Delete 되는 경우 : Data가 지워지지 않고, 사용 안 됨 표시만 해둔다.

       -> Table의 Data 수가 Index의 Data 수가 다를 수 있음

   * UPDATE : 

     * Table에서 Update가 발생하면, Index는 Update를 할 수 없다.
     * Index에서는 Delete가 발생한 후, 새로운 작업의 Insert 작업 / 2 배의 작업이 소요되어 힘들다.

<br>

### Index Column 선택 방법

인덱스는 한 테이블 당 보통 3~5개 정도가 적당한데, 물론 테이블의 목적과 컬럼 수에 따라 개수는 달라질 수 있다. 인덱스는 컬럼을 정해서 설정하는 것으로 후보 컬럼의 특징을 잘 파악해야 하며, 아래 4가지 기준을 사용하면 효율적으로 인덱스를 설정할 수 있다.

1. **카디널리티 (Cardinality) :** 카디널리티란 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표로 대개 중복도가 '낮으면' 카디널리티가 '높다'고 표현한다. 그러다보니 중복도가 낮은 컬럼이 인덱스 설정에 좋다.
2. **선택도 (Selectivity) :** 선택도가 낮을수록 인덱스 설정에 좋은 컬럼으로 데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표
3. **활용도 :** 활용도가 높은 컬럼
4. **중복도 :** 중복도가 없을 수록 인덱스 설정에 좋은 컬럼이다.