# 시간 복잡도

> 하나의 문제를 푸는 알고리즘은 다양할 수 있는데, 다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해, 복잡도를 정의하고 계산함

## 1. 알고리즘 복잡도 계산 항목

1. 시간 복잡도 : 알고리즘 실행 속도
    - 시간 복잡도의 주요 요소는 `"반복문"`이 지배한다.
2. 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

<br>

## 2. 알고리즘 성능 표기법

> 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중 최악의 시간인 Big-O 표기법을 중심으로 익히면 된다.

- Big O (빅-오) 표기법 : O(N)
    - **가장 많이/일반적으로 사용**되며 알고리즘 **최악의 실행 시간**을 표기
    - 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미
- Ω (오메가) 표기법 : Ω(N)
    - 알고리즘 **최상의 실행 시간**을 표기
- Θ (세타) 표기법 : Θ(N)
    - 알고리즘 **평균 실행 시간**을 표기

<br>

## 3. 대문자 O 표기법

- O (입력)
    - 입력 n에 따라 결정되는 시간 복잡도 함수
    - 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
        - O(1) < O(logn <, O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!) 등으로 표기함
    - 단순하게 입력 n에 따라, 몇번 실행되는지를 계산하면 된다.
        - 표현식에 가장 큰 영향을 미치는 n의 단위로 표기한다.
    - 빅 오 입력값 표기 방법 예시
        - 만약 시간 복잡도 함수가 2n^2 + 3n이라면
            - 가장 높은 차수는 2n^2
            - 상수는 실제 큰 영향이 없음
            - 결국 빅 오 표기법으로 O(n^2)

<br>

## 4. 연습 : 시간 복잡도와 빅-오 표기법

### 1. **시간 복잡도 : n, 빅-오 표기법 : O(n)**

```python
def sigma(n):
    total = 0
    for i in range(1, n+1):
            total += i
    return total
```

1. Total 변수 설정 후 0을 저장
2. 임의의 i를 1부터 n까지 1씩 증가시키면서 저장
3. 반복문 안에서 Total 변수에 1씩 증가된 값을 더함  ← 결국 n번 입력
4. 반복문 종료시 Total 출력

### 2. 시간 복잡도 : 1, 빅-오 표기법: O(1)

```python
def sigma(n):
    return int(n * (n +1) / 2)
```

1. n 값을 받자마자 Total 바로 계산  ← 결국 1번의 계산 (반복문이 없음)